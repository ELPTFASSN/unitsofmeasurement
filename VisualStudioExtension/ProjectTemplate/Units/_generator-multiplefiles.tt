<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".txt" encoding="utf-8" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="Man.UnitsOfMeasurement.Parser.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="Man.UnitsOfMeasurement" #>
<#
    Initialize("_definitions.txt");

    List<UnitType> units = new List<UnitType>();
    List<ScaleType> scales = new List<ScaleType>();

    using (StreamReader input = File.OpenText(__inputFilePath))
    {
        Lexer lexer = new Lexer(input, LogParserError);
        Parser parser = new Parser(lexer, units, scales);
        parser.Parse();
    }

    __family = 0;
    foreach (UnitType u in units)
    {
        ProcessUnit(u);
    }

    __scalestartfamily = __family;
    foreach (ScaleType s in scales)
    {
        ProcessScale(s);
    }

    Summarize(units, scales);
    DeleteObsoleteItems();
    __template.ExpandView();
#>

<#+
    int __family;
    int __scalestartfamily;

    string __templateFolder;
    string __inputFilePath;
    string __targetNamespace;

    EnvDTE.Project __project;                   // project containing this template
    EnvDTE.ProjectItem __template;              // this template

    List<string> __savedItems;

    void Initialize(string inputFileName)
    {
        __templateFolder = Path.GetDirectoryName(Host.TemplateFile);
        __inputFilePath = Path.Combine(__templateFolder, inputFileName);
        __project = GetTemplateProject();
        __template = GetTemplateItem(__project.ProjectItems);
        __savedItems = new List<string>();

        __targetNamespace = (string)__template.Properties.Item("CustomToolNamespace").Value;
        if (String.IsNullOrWhiteSpace(__targetNamespace))
            __targetNamespace = (string)__project.Properties.Item("DefaultNamespace").Value;
    }

    EnvDTE.Project GetTemplateProject()
    {
        IServiceProvider serviceProvider = (IServiceProvider)this.Host;
        EnvDTE.DTE dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));    // = (EnvDTE.DTE)serviceProvider.GetCOMService(typeof(EnvDTE.DTE));
        Array projects = (Array)dte.ActiveSolutionProjects;
        return (EnvDTE.Project)projects.GetValue(0);
    }

    EnvDTE.ProjectItem GetTemplateItem(EnvDTE.ProjectItems items)
    {
        if (items != null)
        {
            foreach(EnvDTE.ProjectItem item in items)
            {
                EnvDTE.Property itempath = item.Properties.Item("FullPath");
                if ((itempath != null) && Host.TemplateFile.Equals((string)itempath.Value, StringComparison.OrdinalIgnoreCase))
                    return item;

                EnvDTE.ProjectItem subitem = GetTemplateItem(item.ProjectItems);
                if (subitem != null)
                    return subitem;
            }
        }
        return null;
    }

    void SaveItem(string fileName)
    {
        string filePath = Path.Combine(__templateFolder, fileName);
        File.WriteAllText(filePath, this.GenerationEnvironment.ToString());
        this.GenerationEnvironment.Clear();
        __template.ProjectItems.AddFromFile(filePath);
        __savedItems.Add(fileName);
    }

    void DeleteObsoleteItems()
    {
        string summaryItemName = Path.GetFileNameWithoutExtension(Host.TemplateFile) + ".txt";
        foreach (EnvDTE.ProjectItem item in __template.ProjectItems)
        {
            if (!item.Name.Equals(summaryItemName, StringComparison.OrdinalIgnoreCase) && !__savedItems.Contains(item.Name))
                item.Delete();
        }
    }

    void LogParserError(bool isError, int line, int column, string token, string message)
    {
        var error = new CompilerError(__inputFilePath, line, column, token, message);
        error.IsWarning = !isError;
        this.Errors.Add(error);
    }
#>

<#+
    void ProcessUnit(UnitType u)
    {
        string Unit = u.Name;
        string Sense = u.Sense.Code;
        string Family = (u.Prime == null) ? (__family++).ToString() : String.Format("{0}.Family", u.FamilyPrime().Name);
        string Format = u.Format;
        string Tags = String.Format("\"{0}\"", String.Join("\", \"", u.Tags));
        
        string Factor = u.Factor.Code;
        string Value = u.Factor.Value.Type.Name;
        string One = u.Factor.Value.Type.One.CSString();
        string Zero = u.Factor.Value.Type.Zero.CSString();
#>
/*******************************************************************************

    Units of Measurement for C# applications

    Copyright (C) Marek Aniola

    This program is provided to you under the terms of the license
    as published at https://github.com/mangh/unitsofmeasurement


********************************************************************************/
using System;

namespace <#= __targetNamespace #>
{
    public partial struct <#= Unit #> : IQuantity<<#= Value #>>, IEquatable<<#= Unit #>>, IComparable<<#= Unit #>>, IFormattable
    {
        #region Fields
        private readonly <#= Value #> m_value;
        #endregion

        #region Properties
        public <#= Value #> Value { get { return m_value; } }
        #endregion

        #region Constructor(s)
        public <#= Unit #>(<#= Value #> value)
        {
            m_value = value;
        }
        #endregion

        #region Conversions
        public static explicit operator <#= Unit #>(<#= Value #> q) { return new <#= Unit #>(q); }
<#+
        foreach (MeasureType s in u.Relatives())
        {
            string Relative = ((UnitType)s).Name;
#>
        public static explicit operator <#= Unit #>(<#= Relative #> q) { return new <#= Unit #>((<#= Unit #>.Factor / <#= Relative #>.Factor) * q.Value); }
<#+
        }
#>
        public static <#= Unit #> From(IQuantity<<#= Value #>> q)
        {
            Unit<<#= Value #>> source = new Unit<<#= Value #>>(q);
            if (source.Family != <#= Unit #>.Family) throw new InvalidOperationException(String.Format("Cannot convert \"{0}\" to \"<#= Unit #>\"", q.GetType().Name));
            return new <#= Unit #>((<#= Unit #>.Factor / source.Factor) * q.Value);
        }
        #endregion

        #region IObject / IEquatable<<#= Unit #>>
        public override int GetHashCode() { return m_value.GetHashCode(); }
        public override bool /* IObject */ Equals(object obj) { return (obj is <#= Unit #>) && Equals((<#= Unit #>)obj); }
        public bool /* IEquatable<<#= Unit #>> */ Equals(<#= Unit #> other) { return this.Value == other.Value; }
        #endregion

        #region Comparison / IComparable<<#= Unit #>>
        public static bool operator ==(<#= Unit #> lhs, <#= Unit #> rhs) { return lhs.Value == rhs.Value; }
        public static bool operator !=(<#= Unit #> lhs, <#= Unit #> rhs) { return lhs.Value != rhs.Value; }
        public static bool operator <(<#= Unit #> lhs, <#= Unit #> rhs) { return lhs.Value < rhs.Value; }
        public static bool operator >(<#= Unit #> lhs, <#= Unit #> rhs) { return lhs.Value > rhs.Value; }
        public static bool operator <=(<#= Unit #> lhs, <#= Unit #> rhs) { return lhs.Value <= rhs.Value; }
        public static bool operator >=(<#= Unit #> lhs, <#= Unit #> rhs) { return lhs.Value >= rhs.Value; }
        public int /* IComparable<<#= Unit #>> */ CompareTo(<#= Unit #> other) { return this.Value.CompareTo(other.Value); }
        #endregion

        #region Arithmetic
        // Inner:
        public static <#= Unit #> operator +(<#= Unit #> lhs, <#= Unit #> rhs) { return new <#= Unit #>(lhs.Value + rhs.Value); }
        public static <#= Unit #> operator -(<#= Unit #> lhs, <#= Unit #> rhs) { return new <#= Unit #>(lhs.Value - rhs.Value); }
        public static <#= Unit #> operator ++(<#= Unit #> q) { return new <#= Unit #>(q.Value + <#= One #>); }
        public static <#= Unit #> operator --(<#= Unit #> q) { return new <#= Unit #>(q.Value - <#= One #>); }
        public static <#= Unit #> operator -(<#= Unit #> q) { return new <#= Unit #>(-q.Value); }
        public static <#= Unit #> operator *(<#= Value #> lhs, <#= Unit #> rhs) { return new <#= Unit #>(lhs * rhs.Value); }
        public static <#= Unit #> operator *(<#= Unit #> lhs, <#= Value #> rhs) { return new <#= Unit #>(lhs.Value * rhs); }
        public static <#= Unit #> operator /(<#= Unit #> lhs, <#= Value #> rhs) { return new <#= Unit #>(lhs.Value / rhs); }
        public static <#= Value #> operator /(<#= Unit #> lhs, <#= Unit #> rhs) { return lhs.Value / rhs.Value; }
        // Outer:
<#+
        foreach (BinaryOperation o in u.OuterOperations)
        {
            string lhsValue = (o.Lhs.IsPredefined) ? "lhs" : "lhs.Value";
            string rhsValue = (o.Rhs.IsPredefined) ? "rhs" : "rhs.Value";
            string retValue = (o.Result.IsPredefined) ? 
                String.Format("{0} {1} {2}", lhsValue, o.Operation, rhsValue) :
                String.Format("new {0}({1} {2} {3})", o.Result.Name, lhsValue, o.Operation, rhsValue);
#>
        public static <#= o.Result.Name #> operator <#= o.Operation #>(<#= o.Lhs.Name #> lhs, <#= o.Rhs.Name #> rhs) { return <#= retValue #>; }
<#+
        }
#>
        #endregion

        #region Formatting
        public override string ToString() { return ToString(<#= Unit #>.Format, null); }
        public string ToString(string format) { return ToString(format, null); }
        public string ToString(IFormatProvider fp) { return ToString(<#= Unit #>.Format, fp); }
        public string /* IFormattable */ ToString(string format, IFormatProvider fp)
        {
            return String.Format(fp, format ?? <#= Unit #>.Format, Value, <#= Unit #>.Symbol[0]);
        }
        #endregion

        #region Statics
        private static readonly Dimension s_sense = <#= Sense #>;
        private static readonly int s_family = <#= Family #>;
        private static <#= Value #> s_factor = <#= Factor #>;
        private static string s_format = "<#= Format #>";
        private static readonly SymbolCollection s_symbol = new SymbolCollection(<#= Tags #>);

        private static readonly <#= Unit #> s_one = new <#= Unit #>(<#= One #>);
        private static readonly <#= Unit #> s_zero = new <#= Unit #>(<#= Zero #>);
        
        public static Dimension Sense { get { return s_sense; } }
        public static int Family { get { return s_family; } }
        public static <#= Value #> Factor { get { return s_factor; } set { s_factor = value; } }
        public static string Format { get { return s_format; } set { s_format = value; } }
        public static SymbolCollection Symbol { get { return s_symbol; } }

        public static <#= Unit #> One { get { return s_one; } }
        public static <#= Unit #> Zero { get { return s_zero; } }
        #endregion
    }
}
<#+
        SaveItem(Unit + ".cs");
    }
#>

<#+
    void ProcessScale(ScaleType s)
    {
        string Scale = s.Name;
        string Unit = s.Unit.Name;
        string Offset = s.Offset.Code;
        string Family = (s.Prime == null) ? (__family++).ToString() : String.Format("{0}.Family", s.FamilyPrime().Name);
        string Format = s.Format;

        string Value = s.Unit.Factor.Value.Type.Name;
        string One = s.Unit.Factor.Value.Type.One.CSString();
        string Zero = s.Unit.Factor.Value.Type.Zero.CSString();
#>
/*******************************************************************************

    Units of Measurement for C# applications

    Copyright (C) Marek Aniola

    This program is provided to you under the terms of the license
    as published at https://github.com/mangh/unitsofmeasurement


********************************************************************************/
using System;

namespace <#= __targetNamespace #>
{
<#+
        if (!String.IsNullOrWhiteSpace(s.RefPoint))
        {
#>
    [ScaleReferencePoint("<#= s.RefPoint #>")]
<#+
        }
#>
    public partial struct <#= Scale #> : ILevel<<#= Value #>>, IEquatable<<#= Scale #>>, IComparable<<#= Scale #>>, IFormattable
    {
        #region Fields
        private readonly <#= Unit #> m_level;
        #endregion

        #region Properties
        // instance properties
        public <#= Unit #> Level { get { return m_level; } }
        public <#= Unit #> NormalizedLevel { get { return (m_level - <#= Scale #>.Offset); } }
        // ILevel<<#= Value #>> properties
        IQuantity<<#= Value #>> ILevel<<#= Value #>>.Level { get { return Level; } }
        IQuantity<<#= Value #>> ILevel<<#= Value #>>.NormalizedLevel { get { return NormalizedLevel; } }
        #endregion

        #region Constructor(s)
        public <#= Scale #>(<#= Unit #> level)
        {
            m_level = level;
        }
        public <#= Scale #>(<#= Value #> level) :
            this(new <#= Unit #>(level))
        {
        }
        #endregion

        #region Conversions
        public static explicit operator <#= Scale #>(<#= Value #> q) { return new <#= Scale #>(q); }
        public static explicit operator <#= Scale #>(<#= Unit #> q) { return new <#= Scale #>(q); }

<#+
        foreach (MeasureType x in s.Relatives())
        {
            string Relative = ((ScaleType)x).Name;
#>
        public static explicit operator <#= Scale #>(<#= Relative #> q) { return new <#= Scale #>((<#= Unit #>)(q.NormalizedLevel) + <#= Scale #>.Offset); }
<#+
        }
#>

        public static <#= Scale #> From(ILevel<<#= Value #>> q)
        {
            /* The following 2 statements might be required if you have two (or more) scale families derived from the same units
               but bound to different reference levels. E.g. two families of temperature scales: one with common reference level
               set to absolute zero and the other one with common reference level set to water freeze point.
               This is rather unlikely and the statements are commented out to avoid (likely) superfluous checks. */
               
            // Scale<<#= Value #>> source = new Scale<<#= Value #>>(q);
            // if (source.Family != <#= Scale #>.Family) throw new InvalidOperationException(String.Format("Cannot convert \"{0}\" to \"<#= Scale #>\"", q.GetType().Name));

            return new <#= Scale #>(<#= Unit #>.From(q.NormalizedLevel) + <#= Scale #>.Offset);
        }
        #endregion

        #region IObject / IEquatable<<#= Scale #>>
        public override int GetHashCode() { return m_level.GetHashCode(); }
        public override bool /* IObject */ Equals(object obj) { return (obj is <#= Scale #>) && Equals((<#= Scale #>)obj); }
        public bool /* IEquatable<<#= Scale #>> */ Equals(<#= Scale #> other) { return this.Level == other.Level; }
        #endregion

        #region Comparison / IComparable<<#= Scale #>>
        public static bool operator ==(<#= Scale #> lhs, <#= Scale #> rhs) { return lhs.Level == rhs.Level; }
        public static bool operator !=(<#= Scale #> lhs, <#= Scale #> rhs) { return lhs.Level != rhs.Level; }
        public static bool operator <(<#= Scale #> lhs, <#= Scale #> rhs) { return lhs.Level < rhs.Level; }
        public static bool operator >(<#= Scale #> lhs, <#= Scale #> rhs) { return lhs.Level > rhs.Level; }
        public static bool operator <=(<#= Scale #> lhs, <#= Scale #> rhs) { return lhs.Level <= rhs.Level; }
        public static bool operator >=(<#= Scale #> lhs, <#= Scale #> rhs) { return lhs.Level >= rhs.Level; }
        public int /* IComparable<<#= Scale #>> */ CompareTo(<#= Scale #> other) { return this.Level.CompareTo(other.Level); }
        #endregion

        #region Arithmetic
        public static <#= Scale #> operator +(<#= Scale #> lhs, <#= Unit #> rhs) { return new <#= Scale #>(lhs.Level + rhs); }
        public static <#= Scale #> operator +(<#= Unit #> lhs, <#= Scale #> rhs) { return new <#= Scale #>(lhs + rhs.Level); }
        public static <#= Scale #> operator -(<#= Scale #> lhs, <#= Unit #> rhs) { return new <#= Scale #>(lhs.Level - rhs); }
        public static <#= Unit #> operator -(<#= Scale #> lhs, <#= Scale #> rhs) { return (lhs.Level - rhs.Level); }
        public static <#= Scale #> operator -(<#= Scale #> q) { return new <#= Scale #>(-q.Level); }
        public static <#= Scale #> operator ++(<#= Scale #> q) { return q + <#= Unit #>.One; }
        public static <#= Scale #> operator --(<#= Scale #> q) { return q - <#= Unit #>.One; }
        #endregion

        #region Formatting
        public override string ToString() { return ToString(<#= Scale #>.Format, null); }
        public string ToString(string format) { return ToString(format, null); }
        public string ToString(IFormatProvider fp) { return ToString(<#= Scale #>.Format, fp); }
        public string /* IFormattable */ ToString(string format, IFormatProvider fp)
        {
            return m_level.ToString(format ?? <#= Scale #>.Format, fp);
        }
        #endregion

        #region Statics
        private static readonly <#= Unit #> s_offset = new <#= Unit #>(<#= Offset #>);  // offset to <#= s.RefPointNormalized #>
        private static readonly int s_family = <#= Family #>;
        private static string s_format = "<#= Format #>";
        private static readonly <#= Scale #> s_zero = new <#= Scale #>(<#= Zero #>);
        
        public static <#= Unit #> Offset { get { return s_offset; } }
        public static int Family { get { return s_family; } }
        public static string Format { get { return s_format; } set { s_format = value; } }
        public static <#= Scale #> Zero { get { return s_zero; } }
        #endregion
    }
}
<#+
        SaveItem(Scale + ".cs");
    }
#>

<#+
    void Summarize(List<UnitType> units, List<ScaleType> scales)
    {
        WriteLine("Units and Scales generated on {0}", DateTime.Now);
        WriteLine(String.Empty);

        WriteLine(
@"////////////////////////////////////////////////////////////////////////////////
//
//  U N I T S                                  ({0} units, families: {1} - {2})
//
////////////////////////////////////////////////////////////////////////////////
(family) [dim] name : factor {{tags}}", units.Count, 0, __scalestartfamily - 1);

        foreach (UnitType u in units)
        {
            WriteLine(String.Empty);
            WriteLine("({0}) {1}", u.FamilyPrime().Name, u.ToString());
            WriteLine(String.Empty);

            foreach (MeasureType s in u.Relatives())
            {
                WriteLine("    ({0}){1}", u.Name, ((UnitType)s).Name);
            }
            foreach (BinaryOperation o in u.OuterOperations)
            {
                WriteLine("    {0} = {1} {2} {3}", o.Result.Name, o.Lhs.Name, o.Operation, o.Rhs.Name);
            }
        }

        WriteLine(String.Empty);
        WriteLine(
@"////////////////////////////////////////////////////////////////////////////////
//
//  S C A L E S                               ({0} scales, families: {1} - {2})
//
////////////////////////////////////////////////////////////////////////////////
(family) [dim] name : refpoint = unit offset", scales.Count, __scalestartfamily, __family - 1);

        foreach (ScaleType s in scales)
        {
            WriteLine(String.Empty);
            WriteLine("({0}) {1}", s.FamilyPrime().Name, s.ToString());
            WriteLine(String.Empty);

            foreach (MeasureType x in s.Relatives())
            {
                WriteLine("    ({0}){1}", s.Name, ((ScaleType)x).Name);
            }
        }

        WriteLine(String.Empty);
        WriteLine("// End of report ///////////////////////////////////////////////////////////////");
    }
#>
